# =============================================================================
# Cleanup Workflow - Tech-Debt Resolution
# =============================================================================
#
# PURPOSE:
#   Automates the process of resolving technical debt by fetching issues with
#   a specified label, analyzing them for conflicts, fixing them in parallel
#   or sequentially, validating changes, and creating pull requests.
#
# WORKFLOW STEPS:
#   1. Fetch issues with the specified label from GitHub
#   2. Analyze and select up to N non-conflicting issues to process
#   3. For each selected issue (in parallel or sequential):
#      a. Create a feature branch
#      b. Fix the issue using the issue fixer agent
#      c. Validate and fix code (format, lint, typecheck, test)
#      d. Commit changes and push to remote
#      e. Create pull request with auto-generated summary
#   4. Report summary of all processed issues
#
# INPUTS:
#   - label (string, optional, default: "tech-debt")
#     The GitHub issue label to filter issues for processing.
#     Example: "tech-debt", "refactor", "cleanup"
#
#   - limit (integer, optional, default: 5)
#     Maximum number of issues to process in a single workflow run.
#     Prevents overwhelming the system with too many concurrent operations.
#
#   - parallel (boolean, optional, default: true)
#     Whether to process issues in parallel or sequentially.
#     Parallel processing is faster but may cause conflicts if issues touch
#     the same files. Set to false for safer sequential processing.
#
# CUSTOMIZATION:
#   - Adjust validation stages by overriding the validate_and_fix fragment
#   - Customize issue selection logic by modifying the analyze-issues step
#   - Change commit message format by overriding the commit_and_push fragment
#   - Modify PR creation behavior by overriding the create_pr_with_summary fragment
#   - Add pre/post hooks by adding conditional steps with when clauses
#
# EXAMPLE USAGE:
#   # Use default settings (tech-debt label, 5 issues max, parallel)
#   maverick fly cleanup
#
#   # Process "refactor" labeled issues sequentially
#   maverick fly cleanup -i label=refactor -i parallel=false
#
#   # Process up to 10 "bug" issues
#   maverick fly cleanup -i label=bug -i limit=10
#
# =============================================================================

version: "1.0"
name: cleanup
description: Tech-debt resolution workflow

# Input parameter declarations
inputs:
  label:
    type: string
    required: false
    default: "tech-debt"
    description: Issue label to filter for processing

  limit:
    type: integer
    required: false
    default: 5
    description: Maximum number of issues to process

  parallel:
    type: boolean
    required: false
    default: true
    description: Process issues in parallel (true) or sequentially (false)

  dry_run:
    type: boolean
    required: false
    default: false
    description: |
      When true, log planned operations without executing them.
      Useful for previewing workflow actions before running.

      In dry-run mode:
      - Issue fetching is logged but not executed
      - Issue analysis is skipped
      - Issue processing is skipped
      - No PR is created

      Use this to preview what the workflow would do without making changes.

# Workflow execution steps
steps:
  # ============================================================================
  # Stage 1: Fetch Issues from GitHub
  # ============================================================================
  # Fetch issues from GitHub with the specified label filter.
  #
  # This step:
  # - Calls GitHub CLI to list issues with the target label
  # - Filters by state (open by default)
  # - Respects the limit parameter
  #
  # Output: List of issues with metadata (number, title, body, labels, etc.)
  # ============================================================================
  - name: fetch_issues
    type: python
    action: fetch_github_issues
    when: ${{ not inputs.dry_run }}
    kwargs:
      label: ${{ inputs.label }}
      limit: ${{ inputs.limit }}
      state: open
    metadata:
      progress:
        stage: "fetch_issues"
        weight: 10

  - name: fetch_issues_dry_run
    type: python
    action: log_dry_run
    when: ${{ inputs.dry_run }}
    kwargs:
      operation: "fetch_github_issues"
      details: "Would fetch up to ${{ inputs.limit }} issues with label '${{ inputs.label }}'"
    metadata:
      progress:
        stage: "fetch_issues"
        weight: 10

  # ============================================================================
  # Checkpoint: After Issue Fetching
  # ============================================================================
  # Save workflow state after successfully fetching issues to enable resumption
  # from this point if the workflow is interrupted during analysis or processing.
  # ============================================================================
  - name: checkpoint_after_fetch
    type: checkpoint
    when: ${{ not inputs.dry_run }}
    checkpoint_id: issues_fetched
    metadata:
      progress:
        stage: "checkpoint"
        weight: 1

  # ============================================================================
  # Stage 2: Analyze Issues for Conflicts
  # ============================================================================
  # Analyze issues for conflicts and select the best candidates.
  #
  # Uses an agent to identify non-conflicting issues that can be safely fixed
  # in parallel without causing merge conflicts.
  #
  # The analyzer considers:
  # - File paths affected by each issue
  # - Potential conflicts between issues
  # - Priority and complexity of issues
  #
  # Output: List of selected_issues to process
  # ============================================================================
  - name: analyze_issues
    type: agent
    agent: issue_analyzer
    when: ${{ not inputs.dry_run }}
    context:
      issues: ${{ steps.fetch_issues.output.issues }}
      max_parallel: ${{ inputs.parallel }}
    metadata:
      progress:
        stage: "analyze_issues"
        weight: 10

  - name: analyze_issues_dry_run
    type: python
    action: log_dry_run
    when: ${{ inputs.dry_run }}
    kwargs:
      operation: "analyze_issues"
      details: "Would analyze issues for conflicts and select best candidates"
    metadata:
      progress:
        stage: "analyze_issues"
        weight: 10

  # ============================================================================
  # Stage 3: Process Selected Issues
  # ============================================================================
  # Process selected issues using Python action.
  #
  # The process_selected_issues action handles:
  # - Iteration over selected issues
  # - Parallel or sequential execution based on parallel input
  # - For each issue: branch creation, fixing, validation, commit, PR creation
  #
  # Output: List of processed issues with status and PR URLs
  # ============================================================================
  - name: process_issues
    type: python
    action: process_selected_issues
    when: ${{ not inputs.dry_run }}
    kwargs:
      issues: ${{ steps.analyze_issues.output.selected_issues }}
      parallel: ${{ inputs.parallel }}
    metadata:
      progress:
        stage: "process_issues"
        weight: 60

  - name: process_issues_dry_run
    type: python
    action: log_dry_run
    when: ${{ inputs.dry_run }}
    kwargs:
      operation: "process_selected_issues"
      details: "Would process selected issues"
    metadata:
      progress:
        stage: "process_issues"
        weight: 60

  # ============================================================================
  # Checkpoint: After Issue Processing
  # ============================================================================
  # Save workflow state after successfully processing issues to enable
  # resumption from this point if the workflow is interrupted during summary
  # generation.
  # ============================================================================
  - name: checkpoint_after_processing
    type: checkpoint
    when: ${{ not inputs.dry_run }}
    checkpoint_id: issues_processed
    metadata:
      progress:
        stage: "checkpoint"
        weight: 1

  # ============================================================================
  # Stage 4: Generate Summary Report
  # ============================================================================
  # Generate summary report of cleanup workflow execution.
  #
  # Aggregates results from all processed issues and reports:
  # - Total issues requested vs. processed
  # - Success/failure/skipped counts
  # - List of created PR URLs
  # - Any errors encountered
  #
  # Output: CleanupSummaryResult with complete workflow statistics
  # ============================================================================
  - name: report_summary
    type: python
    action: generate_cleanup_summary
    when: ${{ not inputs.dry_run }}
    kwargs:
      parallel_result: ${{ steps.process_issues.output }}
      sequential_result: null
      total_requested: ${{ inputs.limit }}
      label: ${{ inputs.label }}
      parallel_mode: ${{ inputs.parallel }}
    metadata:
      progress:
        stage: "summary"
        weight: 10

  - name: report_summary_dry_run
    type: python
    action: log_dry_run
    when: ${{ inputs.dry_run }}
    kwargs:
      operation: "generate_cleanup_summary"
      details: "Would generate summary report of all processed issues"
    metadata:
      progress:
        stage: "summary"
        weight: 10
