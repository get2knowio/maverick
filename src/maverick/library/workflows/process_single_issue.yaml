# ==============================================================================
# Process Single Issue Sub-Workflow
# ==============================================================================
#
# PURPOSE:
#   Reusable sub-workflow for processing a single GitHub issue. This workflow
#   is designed to be invoked by the refuel workflow for each issue in a batch
#   of tech-debt items, but can also be used standalone for single-issue
#   processing.
#
# WORKFLOW STAGES:
#   1. Fetch Issue: Retrieve issue details from GitHub
#   2. Create Branch: Create a feature branch for the fix
#   3. Fix Issue: Implement the fix using the issue fixer agent
#   4. Validate: Run validation stages with automatic fix retry loop
#   5. Commit and Push: Generate commit message, commit, and push changes
#   6. Create PR: Generate PR body and create pull request
#
# INPUTS:
#   - issue_number (integer, required): GitHub issue number
#       The issue to fix. This is the only required input.
#       Example: 123
#
# CUSTOMIZATION POINTS:
#   - Override validation stages by overriding the validate_and_fix fragment
#   - Customize commit message format by overriding the commit_and_push fragment
#   - Modify PR creation behavior by overriding the create_pr_with_summary fragment
#   - Add custom context gathering by inserting steps before fix-issue
#   - Change branch naming convention by modifying the create-branch step
#
# DEPENDENCIES:
#   This workflow requires the following fragments (built-in or overridden):
#   - validate_and_fix: Validation-with-retry loop
#   - commit_and_push: Commit message generation and git push
#   - create_pr_with_summary: PR body generation and creation
#
# EXAMPLE USAGE:
#   # As a sub-workflow (typical in refuel workflow)
#   - name: process-issue-123
#     type: subworkflow
#     workflow: process-single-issue
#     inputs:
#       issue_number: 123
#
#   # Standalone execution
#   maverick workflow run process-single-issue -i issue_number=123
#
# COMPARISON WITH OTHER WORKFLOWS:
#   - process_single_issue: Sub-workflow for batch processing (refuel)
#   - quick_fix: Standalone workflow with similar flow but different branch naming
#   - Both workflows share the same core steps but differ in context and naming
#
# AGENT ROLES:
#   - issue_fixer: Analyzes issue and implements the fix
#   - validation_fixer: Automatically fixes validation failures (via fragment)
#   - commit_message_generator: Creates commit message (via fragment)
#   - pr_body_generator: Creates comprehensive PR description (via fragment)
#
# ==============================================================================

version: "1.0"
name: process-single-issue
description: Process a single GitHub issue with fix, validation, and PR creation

# ------------------------------------------------------------------------------
# Input Declarations
# ------------------------------------------------------------------------------
inputs:
  issue_number:
    type: integer
    required: true
    description: GitHub issue number to fix

# ------------------------------------------------------------------------------
# Workflow Steps
# ------------------------------------------------------------------------------
steps:
  # ============================================================================
  # Stage 1: Fetch Issue Details
  # ============================================================================
  # Retrieve the issue from GitHub to gather context for the fix.
  #
  # This step:
  # - Fetches issue metadata (title, body, labels, assignees)
  # - Retrieves issue comments for additional context
  # - Validates that the issue exists and is open
  # - Checks that the issue is not already assigned to a PR
  #
  # The issue details are used by subsequent steps to:
  # - Generate an appropriate branch name
  # - Provide context to the fixer agent
  # - Create meaningful commit messages
  # - Populate the PR description
  #
  # Output: Issue object with title, body, labels, state, comments
  # ============================================================================
  - name: fetch_issue
    type: python
    action: fetch_github_issue
    kwargs:
      issue_number: ${{ inputs.issue_number }}
    metadata:
      progress:
        stage: "fetch_issue"
        weight: 5

  # ============================================================================
  # Stage 2: Create Feature Branch
  # ============================================================================
  # Create a dedicated branch for implementing this fix.
  #
  # This step:
  # - Generates a branch name from the issue number (fix/issue-N format)
  # - Creates the branch from the current main/master branch
  # - Checks out the new branch
  # - Validates that the workspace is clean
  #
  # Branch naming convention:
  # - Format: fix/issue-{issue_number}
  # - Example: For issue #123, creates branch "fix/issue-123"
  # - Consistent naming enables easy tracking and automation
  # - Different from quick_fix which uses "fix/quick-fix" as the branch name
  #
  # To customize the branch name format, override this step and modify
  # the branch_name parameter.
  #
  # Output: Branch name and creation status
  # ============================================================================
  - name: create_branch
    type: python
    action: create_git_branch
    kwargs:
      branch_name: "fix/issue-${{ inputs.issue_number }}"
      base: main
    metadata:
      progress:
        stage: "create_branch"
        weight: 5

  # ============================================================================
  # Stage 3: Implement the Fix
  # ============================================================================
  # Use the issue fixer agent to analyze and implement the fix.
  #
  # This step:
  # - Provides the agent with full issue context (title, body, comments)
  # - Grants the agent access to read/write files and run git commands
  # - Allows the agent to search the codebase for relevant code
  # - Enables the agent to run tests to verify the fix
  #
  # The issue fixer agent:
  # - Analyzes the issue description to understand the problem
  # - Searches the codebase to locate the relevant code
  # - Implements the fix following project conventions
  # - Adds or updates tests to verify the fix works
  # - May make multiple commits if the fix involves multiple components
  #
  # Context builder: issue_fix_context
  # - Includes: issue details, related files, project conventions, test patterns
  #
  # The agent has access to tools for:
  # - File operations (read, write, search)
  # - Git operations (status, diff, commit)
  # - Running tests and validation
  # - Searching documentation and similar code
  #
  # Output: Fix summary with changed files and implementation notes
  # ============================================================================
  - name: fix_issue
    type: agent
    agent: issue_fixer
    context:
      issue_number: ${{ inputs.issue_number }}
      issue_title: ${{ steps.fetch_issue.output.title }}
      issue_body: ${{ steps.fetch_issue.output.body }}
      branch_name: ${{ steps.create_branch.output.branch_name }}
    metadata:
      progress:
        stage: "fix_issue"
        weight: 40

  # ============================================================================
  # Stage 4: Validation and Fix Loop
  # ============================================================================
  # Run validation stages with automatic retry and fix loop.
  #
  # This invokes the validate_and_fix fragment, which:
  # - Runs validation stages (format, lint, typecheck, test)
  # - On failure, invokes fixer agent to attempt automatic fixes
  # - Retries validation up to max_attempts times
  # - Reports final validation status
  #
  # The default stages are:
  # - format: Code formatting (ruff, black, etc.)
  # - lint: Linting (ruff, pylint, etc.)
  # - typecheck: Type checking (mypy)
  # - test: Test suite execution (pytest)
  #
  # Process single issue workflow uses conservative settings:
  # - max_attempts: 3 (reasonable for most fixes)
  # - All standard validation stages enabled
  #
  # To customize validation:
  # - Override this step's inputs to adjust stages or max_attempts
  # - Override the validate_and_fix fragment for custom fix logic
  # - Add skip conditions if certain issues don't require validation
  #
  # Output: Validation result with status and any remaining issues
  # ============================================================================
  - name: validate_and_fix
    type: subworkflow
    workflow: validate-and-fix
    inputs:
      stages:
        - format
        - lint
        - typecheck
        - test
      max_attempts: 3
      fixer_agent: validation_fixer
    metadata:
      progress:
        stage: "validation"
        weight: 25

  # ============================================================================
  # Stage 5: Commit and Push
  # ============================================================================
  # Generate a commit message based on the issue and push to remote.
  #
  # This invokes the commit_and_push fragment, which:
  # - Analyzes git diff to understand what changed
  # - Generates a conventional commit message referencing the issue
  # - Creates the commit with appropriate co-author attribution
  # - Pushes to the remote branch
  #
  # Commit message format:
  # - Follows conventional commits (fix:, feat:, etc.)
  # - Includes issue reference for traceability
  # - Example: "fix: resolve race condition in cache layer (#123)"
  #
  # The message generation considers:
  # - Issue title and description
  # - Changed files and their context
  # - Type of change (fix, feature, refactor, etc.)
  #
  # The commit_and_push fragment auto-generates the message if not provided,
  # so we don't pass an explicit message here.
  #
  # Output: Commit SHA and push status
  # ============================================================================
  - name: commit_and_push
    type: subworkflow
    workflow: commit-and-push
    inputs:
      push: true
    metadata:
      progress:
        stage: "commit"
        weight: 10

  # ============================================================================
  # Stage 6: Create Pull Request
  # ============================================================================
  # Generate PR body and create the pull request.
  #
  # This invokes the create_pr_with_summary fragment, which:
  # - Generates a comprehensive PR description summarizing the fix
  # - Links to the issue being fixed
  # - Includes test plan and verification steps
  # - Creates the PR via GitHub CLI
  # - Applies appropriate labels (e.g., "bug", "tech-debt")
  # - Automatically closes the linked issue when PR is merged
  #
  # PR creation settings for process_single_issue:
  # - base_branch: "main" (merge target)
  # - draft: false (ready for immediate review)
  # - Auto-generated title: Based on issue and commit messages
  #
  # The PR body generation includes:
  # - Summary of the fix implementation
  # - Link to the original issue (with "Closes #N" for auto-close)
  # - List of changed files
  # - Validation results
  # - Test coverage (if applicable)
  #
  # To create a draft PR for complex fixes, override this step:
  # ```yaml
  # inputs:
  #   draft: true
  # ```
  #
  # Output: PR number and URL
  # ============================================================================
  - name: create_pr
    type: subworkflow
    workflow: create-pr-with-summary
    inputs:
      base_branch: main
      draft: false
    metadata:
      progress:
        stage: "pr_creation"
        weight: 15
