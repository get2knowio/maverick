# ==============================================================================
# Quick Fix Workflow - Rapid Issue Resolution
# ==============================================================================
#
# PURPOSE:
#   Provides a streamlined workflow for quickly fixing a single GitHub issue.
#   This workflow is optimized for speed and simplicity, handling the entire
#   lifecycle from issue fetch to pull request creation with minimal
#   configuration required from the user.
#
# WORKFLOW STAGES:
#   1. Fetch Issue: Retrieve issue details from GitHub
#   2. Create Branch: Create a feature branch for the fix
#   3. Fix Issue: Implement the fix using the issue fixer agent
#   4. Validate: Run validation stages with automatic fix retry loop
#   5. Commit and Push: Generate commit message, commit, and push changes
#   6. Create PR: Generate PR body and create pull request
#
# INPUTS:
#   - issue_number (integer, required): GitHub issue number
#       The issue to fix. This is the only required input - the workflow
#       handles all other aspects automatically.
#       Example: 123
#
# CUSTOMIZATION POINTS:
#   - Override this workflow to add pre/post hooks or custom validation
#   - Adjust validation stages by overriding the validate_and_fix fragment
#   - Customize commit message format by overriding the commit_and_push fragment
#   - Modify PR creation behavior by overriding the create_pr_with_summary fragment
#   - Add custom context gathering by inserting steps before fix-issue
#   - Change branch naming convention by modifying the create-branch step
#
# DEPENDENCIES:
#   This workflow requires the following fragments (built-in or overridden):
#   - validate_and_fix: Validation-with-retry loop
#   - commit_and_push: Commit message generation and git push
#   - create_pr_with_summary: PR body generation and creation
#
# EXAMPLE USAGE:
#   # Fix issue #123
#   maverick workflow run quick_fix -i issue_number=123
#
#   # Alternative: Use positional argument if CLI supports it
#   maverick workflow run quick_fix 123
#
# COMPARISON WITH OTHER WORKFLOWS:
#   - Use 'fly' for spec-based feature development with task lists
#   - Use 'refuel' for batch processing multiple tech-debt issues
#   - Use 'quick_fix' for single-issue rapid resolution
#
# AGENT ROLES:
#   - issue_fixer: Analyzes issue and implements the fix
#   - validation_fixer: Automatically fixes validation failures (via fragment)
#   - pr_generator: Creates comprehensive PR description (via fragment)
#
# ==============================================================================

version: "1.0"
name: quick-fix
description: Quick issue fix workflow

# ------------------------------------------------------------------------------
# Input Declarations
# ------------------------------------------------------------------------------
inputs:
  issue_number:
    type: integer
    required: true
    description: GitHub issue number to fix

# ------------------------------------------------------------------------------
# Workflow Steps
# ------------------------------------------------------------------------------
steps:
  # ============================================================================
  # Stage 1: Fetch Issue Details
  # ============================================================================
  # Retrieve the issue from GitHub to gather context for the fix.
  #
  # This step:
  # - Fetches issue metadata (title, body, labels, assignees)
  # - Retrieves issue comments for additional context
  # - Validates that the issue exists and is open
  # - Checks that the issue is not already assigned to a PR
  #
  # The issue details are used by subsequent steps to:
  # - Generate an appropriate branch name
  # - Provide context to the fixer agent
  # - Create meaningful commit messages
  # - Populate the PR description
  #
  # Output: Issue object with title, body, labels, state, comments
  # ============================================================================
  - name: fetch_issue
    type: python
    action: fetch_github_issue
    kwargs:
      issue_number: ${{ inputs.issue_number }}

  # ============================================================================
  # Stage 2: Create Feature Branch
  # ============================================================================
  # Create a dedicated branch for implementing this fix.
  #
  # This step:
  # - Generates a branch name from the issue number (fix/issue-N format)
  # - Creates the branch from the current main/master branch
  # - Checks out the new branch
  # - Validates that the workspace is clean
  #
  # Branch naming convention:
  # - Format: fix/issue-{issue_number}
  # - Example: For issue #123, creates branch "fix/issue-123"
  # - Consistent naming enables easy tracking and automation
  #
  # To customize the branch name format, override this step and modify
  # the format() expression or replace it with a custom Python action.
  #
  # Output: Branch name and creation status
  # ============================================================================
  - name: create_branch
    type: python
    action: create_git_branch
    kwargs:
      branch_name: "fix/quick-fix"
      base: main

  # ============================================================================
  # Stage 3: Implement the Fix
  # ============================================================================
  # Use the issue fixer agent to analyze and implement the fix.
  #
  # This step:
  # - Provides the agent with full issue context (title, body, comments)
  # - Grants the agent access to read/write files and run git commands
  # - Allows the agent to search the codebase for relevant code
  # - Enables the agent to run tests to verify the fix
  #
  # The issue fixer agent:
  # - Analyzes the issue description to understand the problem
  # - Searches the codebase to locate the relevant code
  # - Implements the fix following project conventions
  # - Adds or updates tests to verify the fix works
  # - May make multiple commits if the fix involves multiple components
  #
  # Context builder: issue_fix_context
  # - Includes: issue details, related files, project conventions, test patterns
  #
  # The agent has access to tools for:
  # - File operations (read, write, search)
  # - Git operations (status, diff, commit)
  # - Running tests and validation
  # - Searching documentation and similar code
  #
  # Output: Fix summary with changed files and implementation notes
  # ============================================================================
  - name: fix_issue
    type: agent
    agent: issue_fixer
    context:
      issue_number: ${{ inputs.issue_number }}
      issue_title: ${{ steps.fetch_issue.output.title }}
      issue_body: ${{ steps.fetch_issue.output.body }}
      branch_name: ${{ steps.create_branch.output.branch_name }}

  # ============================================================================
  # Stage 4: Validation and Fix Loop
  # ============================================================================
  # Run validation stages with automatic retry and fix loop.
  #
  # This invokes the validate_and_fix fragment, which:
  # - Runs validation stages (format, lint, typecheck, test)
  # - On failure, invokes fixer agent to attempt automatic fixes
  # - Retries validation up to max_attempts times
  # - Reports final validation status
  #
  # The default stages are:
  # - format: Code formatting (ruff, black, etc.)
  # - lint: Linting (ruff, pylint, etc.)
  # - typecheck: Type checking (mypy)
  # - test: Test suite execution (pytest)
  #
  # Quick fix workflow uses conservative settings:
  # - max_attempts: 3 (reasonable for simple fixes)
  # - All standard validation stages enabled
  #
  # To customize validation:
  # - Override this step's inputs to adjust stages or max_attempts
  # - Override the validate_and_fix fragment for custom fix logic
  # - Add skip conditions if certain issues don't require validation
  #
  # For example, documentation-only fixes might skip typecheck and test:
  # ```yaml
  # inputs:
  #   stages: [format, lint]
  #   max_attempts: 1
  # when: ${{ 'docs' in steps.fetch-issue.output.labels }}
  # ```
  #
  # Output: Validation result with status and any remaining issues
  # ============================================================================
  - name: validate_and_fix
    type: subworkflow
    workflow: validate-and-fix
    inputs:
      stages:
        - format
        - lint
        - typecheck
        - test
      max_attempts: 3
      fixer_agent: validation_fixer

  # ============================================================================
  # Stage 5: Commit and Push
  # ============================================================================
  # Generate a commit message based on the issue and push to remote.
  #
  # This invokes the commit_and_push fragment, which:
  # - Analyzes git diff to understand what changed
  # - Generates a conventional commit message referencing the issue
  # - Creates the commit with appropriate co-author attribution
  # - Pushes to the remote branch
  #
  # Commit message format:
  # - Follows conventional commits (fix:, feat:, etc.)
  # - Includes issue reference for traceability
  # - Example: "fix: resolve race condition in cache layer (#123)"
  #
  # The message generation considers:
  # - Issue title and description
  # - Changed files and their context
  # - Type of change (fix, feature, refactor, etc.)
  #
  # To use a custom commit message, pass it explicitly:
  # ```yaml
  # inputs:
  #   message: "fix: custom commit message\n\nCloses #123"
  # ```
  #
  # Output: Commit SHA and push status
  # ============================================================================
  - name: commit_and_push
    type: subworkflow
    workflow: commit-and-push
    inputs:
      message: "Fix issue via quick-fix workflow"
      push: true

  # ============================================================================
  # Stage 6: Create Pull Request
  # ============================================================================
  # Generate PR body and create the pull request.
  #
  # This invokes the create_pr_with_summary fragment, which:
  # - Generates a comprehensive PR description summarizing the fix
  # - Links to the issue being fixed
  # - Includes test plan and verification steps
  # - Creates the PR via GitHub CLI
  # - Applies appropriate labels (e.g., "bug", "quick-fix")
  # - Automatically closes the linked issue when PR is merged
  #
  # PR creation settings for quick_fix:
  # - base_branch: "main" (merge target)
  # - draft: false (ready for immediate review)
  # - Auto-generated title: "Fix #{issue_number}: {issue_title}"
  #
  # The PR body generation includes:
  # - Summary of the fix implementation
  # - Link to the original issue (with "Closes #N" for auto-close)
  # - List of changed files
  # - Validation results
  # - Test coverage (if applicable)
  #
  # To create a draft PR for complex fixes:
  # ```yaml
  # inputs:
  #   draft: true
  # ```
  #
  # To customize the base branch:
  # ```yaml
  # inputs:
  #   base_branch: develop
  # ```
  #
  # Output: PR number and URL
  # ============================================================================
  - name: create_pr
    type: subworkflow
    workflow: create-pr-with-summary
    inputs:
      base_branch: main
      draft: false
      title: "Quick fix for issue"
