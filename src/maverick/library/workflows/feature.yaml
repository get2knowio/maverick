# ==============================================================================
# Feature Workflow - Full Spec-Based Development
# ==============================================================================
#
# The "feature" workflow orchestrates a complete feature implementation from a
# task list through to pull request creation. It is Maverick's primary workflow
# for spec-based development, handling implementation, validation, review, and PR
# management in a single coordinated flow.
#
# WORKFLOW STAGES:
#   1. Init: Workspace initialization and branch sync
#   2. Implement: Execute all tasks from tasks.md
#   3. Validate: Run validation stages with automatic fix retry loop
#   4. Commit: Generate commit message and push changes
#   5. Review: Code review (optional, skippable)
#   6. Create PR: Generate PR body and create pull request
#
# INPUTS:
#   - branch_name (string, required): Feature branch name
#       The Git branch to work on. Will be created or checked out.
#       Example: "025-builtin-workflow-library"
#
#   - task_file (string, optional): Path to tasks.md file
#       Location of the task list to execute. If omitted, workflow will
#       auto-detect by searching for tasks.md in standard locations:
#       - specs/<branch-name>/tasks.md
#       - ./tasks.md
#       Example: "specs/025-builtin-workflow-library/tasks.md"
#
#   - skip_review (boolean, optional, default: false): Skip code review stage
#       Set to true to bypass the code review step. Useful for:
#       - Small changes or documentation updates
#       - Emergency fixes
#       - Work-in-progress PRs
#       Example: true
#
#   - dry_run (boolean, optional, default: false): Preview mode
#       Set to true to preview workflow actions without executing them.
#       Logs all planned operations instead of making actual changes.
#       Example: true
#
# CUSTOMIZATION POINTS:
#   - Override this workflow in your project to customize stages
#   - Adjust validation stages in validate-and-fix step inputs
#   - Replace review agent or add additional review steps
#   - Customize commit message generation via commit-and-push fragment
#   - Override fragments to customize common patterns across workflows
#
# DEPENDENCIES:
#   This workflow requires the following fragments (built-in or overridden):
#   - validate_and_fix: Validation-with-retry loop
#   - commit_and_push: Commit message generation and git push
#   - create_pr_with_summary: PR body generation and creation
#
# EXAMPLE USAGE:
#   # Basic usage (auto-detect task file)
#   maverick fly feature -i branch_name=025-builtin-workflow-library
#
#   # Explicit task file
#   maverick fly feature -i branch_name=025-builtin-workflow-library \
#     -i task_file=specs/025-builtin-workflow-library/tasks.md
#
#   # Skip code review
#   maverick fly feature -i branch_name=025-builtin-workflow-library \
#     -i skip_review=true
#
#   # Dry run (preview without executing)
#   maverick fly feature -i branch_name=025-builtin-workflow-library \
#     -i dry_run=true
#
# ==============================================================================

version: "1.0"
name: feature
description: Full spec-based development workflow

# ------------------------------------------------------------------------------
# Input Declarations
# ------------------------------------------------------------------------------
inputs:
  branch_name:
    type: string
    required: true
    description: Feature branch name

  task_file:
    type: string
    required: false
    description: |
      Path to tasks.md (auto-detect if omitted)

      Auto-detection: If not specified, searches for tasks.md in:
      1. specs/<branch-name>/tasks.md
      2. Current directory (./tasks.md)

  skip_review:
    type: boolean
    required: false
    default: false
    description: Skip code review stage

  dry_run:
    type: boolean
    required: false
    default: false
    description: |
      When true, log planned operations without executing them.
      Useful for previewing workflow actions before running.

      In dry-run mode:
      - Workspace initialization is logged but not executed
      - Task implementation is skipped (logs task list only)
      - Validation is skipped
      - No commits or pushes are made
      - No code review is performed
      - No PR is created

      Use this to preview what the workflow would do without making changes.

# ------------------------------------------------------------------------------
# Workflow Steps
# ------------------------------------------------------------------------------
steps:
  # ============================================================================
  # Stage 1: Workspace Initialization
  # ============================================================================
  # Initialize the workspace by syncing the feature branch with the base branch
  # (typically main), ensuring we're starting from a clean, up-to-date state.
  #
  # This step:
  # - Checks out or creates the feature branch
  # - Syncs with origin/main (fast-forward if possible)
  # - Validates that the workspace is clean
  #
  # Output: Workspace state including current branch, base branch, and sync status
  # ============================================================================
  - name: init
    type: python
    action: init_workspace
    when: ${{ not inputs.dry_run }}
    kwargs:
      branch_name: ${{ inputs.branch_name }}
    metadata:
      progress:
        stage: "initialization"
        weight: 5

  - name: init_dry_run
    type: python
    action: log_dry_run
    when: ${{ inputs.dry_run }}
    kwargs:
      operation: "init_workspace"
      details: "Would initialize workspace on branch ${{ inputs.branch_name }}"
    metadata:
      progress:
        stage: "initialization"
        weight: 5

  # ============================================================================
  # Stage 2: Get Phase Names
  # ============================================================================
  # Extract phase names from tasks.md to enable phase-level iteration.
  # Each phase will be executed separately with Claude handling parallelization
  # of [P] marked tasks within the phase.
  #
  # Uses auto-detected task file from init step if not explicitly provided.
  # ============================================================================
  - name: get_phases
    type: python
    action: get_phase_names
    when: ${{ not inputs.dry_run and steps.init.output.task_file_path }}
    kwargs:
      task_file: ${{ inputs.task_file or steps.init.output.task_file_path }}
    metadata:
      progress:
        stage: "initialization"
        weight: 2

  # ============================================================================
  # Stage 2: Implementation by Phase
  # ============================================================================
  # Execute tasks phase-by-phase using the Implementer agent.
  #
  # This step iterates over each phase in tasks.md:
  # - Each phase is executed as a single Claude invocation
  # - Claude handles parallelization of [P] marked tasks within the phase
  # - After each phase: validate, commit, and checkpoint
  #
  # Benefits of phase-level execution:
  # - Coarser-grained control with better context coherence
  # - Claude decides optimal parallelization strategy
  # - Atomic commits per phase for cleaner git history
  # - Resume from any phase checkpoint on failure
  #
  # The implementer agent has access to:
  # - File read/write operations
  # - Git operations (commit, status, diff)
  # - Project context from the spec directory
  #
  # Output: Implementation results per phase including completed tasks
  # ============================================================================
  - name: implement_by_phase
    type: loop
    when: ${{ not inputs.dry_run and steps.get_phases.output }}
    for_each: ${{ steps.get_phases.output }}
    # max_concurrency defaults to 1 (sequential)
    steps:
      # Execute all tasks in this phase
      - name: implement_phase
        type: agent
        agent: implementer
        context:
          task_file: ${{ inputs.task_file or steps.init.output.task_file_path }}
          phase_name: ${{ item }}
          branch: ${{ inputs.branch_name }}
        metadata:
          progress:
            stage: "implementation"
            phase: ${{ item }}
            weight: 10

      # Validate after each phase (fail fast)
      - name: validate_phase
        type: subworkflow
        workflow: validate-and-fix
        inputs:
          stages:
            - format
            - lint
            - typecheck
            - test
          max_attempts: 2 # Fewer attempts per phase
          fixer_agent: validation_fixer
        metadata:
          progress:
            stage: "validation"
            phase: ${{ item }}
            weight: 5

      # Commit phase changes
      - name: commit_phase
        type: subworkflow
        workflow: commit-and-push
        when: ${{ steps.validate_phase.output.success }}
        inputs:
          push: false # Don't push until all phases done
          commit_message: "feat(${{ item }}): complete phase tasks"
        metadata:
          progress:
            stage: "commit"
            phase: ${{ item }}
            weight: 2

      # Checkpoint after phase completion
      - name: checkpoint_phase
        type: checkpoint
        checkpoint_id: "phase_${{ index }}_complete"
        metadata:
          progress:
            stage: "checkpoint"
            phase: ${{ item }}
            weight: 1

  # Fallback: Single-phase implementation (no phases in task file)
  - name: implement_no_phases
    type: agent
    agent: implementer
    when: ${{ not inputs.dry_run and not steps.get_phases.output and steps.init.output.task_file_path }}
    context:
      task_file: ${{ inputs.task_file or steps.init.output.task_file_path }}
      branch: ${{ inputs.branch_name }}
    metadata:
      progress:
        stage: "implementation"
        weight: 40

  - name: implement_dry_run
    type: python
    action: log_dry_run
    when: ${{ inputs.dry_run }}
    kwargs:
      operation: "implement_tasks_by_phase"
      details: "Would execute tasks from task file, phase by phase with per-phase validation and commits"
    metadata:
      progress:
        stage: "implementation"
        weight: 40

  # ============================================================================
  # Checkpoint: After All Implementation
  # ============================================================================
  # Save workflow state after successful implementation to enable resumption
  # from this point if the workflow is interrupted during validation or review.
  # ============================================================================
  - name: checkpoint_after_implementation
    type: checkpoint
    when: ${{ not inputs.dry_run }}
    checkpoint_id: implementation_complete
    metadata:
      progress:
        stage: "checkpoint"
        weight: 1

  # ============================================================================
  # Stage 3: Final Validation (if not done per-phase)
  # ============================================================================
  # Run final validation if phases were not used (fallback path).
  # When phases are used, validation happens per-phase above.
  # ============================================================================
  - name: validate_and_fix
    type: subworkflow
    workflow: validate-and-fix
    when: ${{ not inputs.dry_run and not steps.get_phases.output }}
    inputs:
      stages:
        - format
        - lint
        - typecheck
        - test
      max_attempts: 3
      fixer_agent: validation_fixer
    metadata:
      progress:
        stage: "validation"
        weight: 25

  - name: validate_dry_run
    type: python
    action: log_dry_run
    when: ${{ inputs.dry_run }}
    kwargs:
      operation: "validate_and_fix"
      details: "Would run validation stages: format, lint, typecheck, test (max 3 fix attempts)"
    metadata:
      progress:
        stage: "validation"
        weight: 25

  # ============================================================================
  # Checkpoint: After Validation
  # ============================================================================
  # Save workflow state after successful validation to enable resumption from
  # this point if the workflow is interrupted during commit/review/PR.
  # ============================================================================
  - name: checkpoint_after_validation
    type: checkpoint
    when: ${{ not inputs.dry_run }}
    checkpoint_id: validation_complete
    metadata:
      progress:
        stage: "checkpoint"
        weight: 1

  # ============================================================================
  # Stage 4: Commit and Push
  # ============================================================================
  # Generate a commit message based on changes and push to remote.
  #
  # This invokes the commit_and_push fragment, which:
  # - Analyzes git diff and recent commits to understand changes
  # - Generates a conventional commit message
  # - Creates the commit with appropriate co-author attribution
  # - Pushes to the remote branch
  #
  # The commit message generation considers:
  # - Changed files and their context
  # - Recent commit history for style consistency
  # - Task list for understanding the "why" of changes
  #
  # Output: Commit SHA and push status
  # ============================================================================
  - name: commit_and_push
    type: subworkflow
    workflow: commit-and-push
    when: ${{ not inputs.dry_run }}
    metadata:
      progress:
        stage: "commit"
        weight: 10

  - name: commit_dry_run
    type: python
    action: log_dry_run
    when: ${{ inputs.dry_run }}
    kwargs:
      operation: "commit_and_push"
      details: "Would generate commit message, create commit, and push to remote branch"
    metadata:
      progress:
        stage: "commit"
        weight: 10

  # ============================================================================
  # Stage 5: Code Review (Optional)
  # ============================================================================
  # Perform automated code review using the code reviewer agent.
  #
  # This step is CONDITIONAL - it only runs when skip_review is false AND
  # dry_run is false. The condition expression evaluates to:
  # - true when both skip_review and dry_run are false or omitted
  # - false when either skip_review or dry_run is explicitly set to true
  #
  # The code reviewer agent:
  # - Analyzes the diff between the current branch and base branch
  # - Checks for architecture consistency
  # - Validates adherence to project conventions (CLAUDE.md)
  # - Identifies potential issues or improvements
  #
  # Context builder: review_context
  # - Includes: git diff, changed files, project conventions, architecture docs
  #
  # To skip review for specific scenarios:
  # - Small changes: maverick workflow run fly -i skip_review=true
  # - Documentation updates: Often safe to skip
  # - Emergency fixes: May need to skip and review post-merge
  #
  # Output: Review findings and recommendations
  # ============================================================================
  - name: review
    type: agent
    agent: code_reviewer
    context: review_context
    when: ${{ not inputs.skip_review and not inputs.dry_run }}
    metadata:
      progress:
        stage: "review"
        weight: 10

  - name: review_dry_run
    type: python
    action: log_dry_run
    when: ${{ inputs.dry_run and not inputs.skip_review }}
    kwargs:
      operation: "code_review"
      details: "Would perform automated code review and architecture analysis"
    metadata:
      progress:
        stage: "review"
        weight: 10

  # ============================================================================
  # Stage 6: Create Pull Request
  # ============================================================================
  # Generate PR body and create the pull request.
  #
  # This invokes the create_pr_with_summary fragment, which:
  # - Generates a comprehensive PR description summarizing changes
  # - Includes links to related issues and specs
  # - Creates the PR via GitHub CLI
  # - Applies appropriate labels and reviewers (if configured)
  #
  # The PR body generation considers:
  # - Commit history since branch divergence from base
  # - Task list and spec artifacts
  # - Review findings (if review was run)
  #
  # Default settings:
  # - base_branch: "main"
  # - draft: false (ready for review)
  #
  # To customize PR creation, override this step's inputs or override the
  # create_pr_with_summary fragment in your project.
  #
  # Output: PR number and URL
  # ============================================================================
  - name: create_pr
    type: subworkflow
    workflow: create-pr-with-summary
    when: ${{ not inputs.dry_run }}
    inputs:
      base_branch: main
      draft: false
    metadata:
      progress:
        stage: "pr_creation"
        weight: 10

  - name: create_pr_dry_run
    type: python
    action: log_dry_run
    when: ${{ inputs.dry_run }}
    kwargs:
      operation: "create_pr"
      details: "Would generate PR body and create pull request against main (ready for review)"
    metadata:
      progress:
        stage: "pr_creation"
        weight: 10
